import { BigFloatBase } from './BigFloatBase';
export declare const dekkerSplitter: number;
export declare const limbsPerDigit53: number;
/** Arbitrary precision floating point number. Based on a multiple-component
  * expansion format and error free transformations.
  *
  * Maximum exponent is the same as for plain JavaScript numbers,
  * least significant representable binary digit is 2^-1074. */
export declare class BigFloat53 implements BigFloatBase<BigFloat53> {
    /** @param value Initial value, a plain JavaScript floating point number
      * (IEEE 754 double precision). */
    constructor(value?: BigFloat53 | number | string, base?: number);
    clone(): BigFloat53;
    /** Set value to zero.
      *
      * @return This object, for chaining. */
    setZero(): this;
    setValue(other: BigFloat53 | number | string, base?: number): this;
    private setBig;
    /** Set value to a plain JavaScript floating point number
      * (IEEE 754 double precision).
      *
      * @param value New value.
      * @return This object, for chaining. */
    private setNumber;
    private setString;
    /** Set value to the sum of two JavaScript numbers.
      *
      * @param a Augend.
      * @param b Addend.
      * @return This object, for chaining. */
    setSum(a: number, b: number): this;
    /** Set value to the product of two JavaScript numbers.
      * @param a Multiplicand.
      * @param b Multiplier.
      * @return This object, for chaining. */
    setProduct(a: number, b: number): this;
    /** See Compress from Shewchuk page 25. */
    normalize(): this;
    /** Multiply this arbitrary precision float by a number.
      * See Scale-Expansion from Shewchuk page 21.
      *
      * @param b Multiplier, a JavaScript floating point number.
      * @param product Arbitrary precision float to overwrite with result.
      * @return Modified product object. */
    mulSmall(b: number, product: BigFloat53): BigFloat53;
    /** Multiply this by an arbitrary precision multiplier.
      * Pass all components of the multiplier to mulSmall and sum the products.
      *
      * @param multiplier Number or arbitrary precision float.
      * @param product Arbitrary precision float to overwrite with result.
      * @return Modified product object. */
    private mulBig;
    /** Multiply number or arbitrary precision float with this one
      * and store result in another BigFloat53.
      *
      * @param multiplier Number or arbitrary precision float.
      * @param product Arbitrary precision float to overwrite with result.
      * If omitted, a new one is allocated.
      * @return Modified product object. */
    mul(multiplier: number | BigFloat53, product?: BigFloat53): BigFloat53;
    cmp: (other: number | BigFloat53) => number;
    isZero(): boolean;
    getSign(): 0 | 1 | -1;
    /** Return an arbitrary number with sign matching the result of this - other. */
    deltaFrom(other: number | BigFloat53): number;
    /** Add a number to this arbitrary precision float.
      * See Grow-Expansion from Shewchuk page 10.
      *
      * @param b JavaScript floating point number to add.
      * @param sum Arbitrary precision float to overwrite with result.
      * @return Modified sum object. */
    addSmall(b: number, sum: BigFloat53): BigFloat53;
    /** Add another arbitrary precision float (multiplied by sign) to this one.
      * See Fast-Expansion-Sum from Shewchuk page 13.
      *
      * @param sign Multiplier for negating addend to implement subtraction.
      * @param sum Arbitrary precision float to overwrite with result.
      * @return Modified sum object. */
    private addBig;
    private addSub;
    /** Add number or arbitrary precision float to this one
      * and store result in another BigFloat53.
      *
      * @param addend Number or arbitrary precision float.
      * @param sum Arbitrary precision float to overwrite with result.
      * If omitted, a new one is allocated.
      * @return Modified sum object. */
    add(addend: number | BigFloat53, sum?: BigFloat53): BigFloat53;
    /** Subtract number or arbitrary precision float from this one
      * and store result in another BigFloat53.
      *
      * @param subtrahend Number or arbitrary precision float.
      * @param difference Arbitrary precision float to overwrite with result.
      * If omitted, a new one is allocated.
      * @return Modified difference object. */
    sub(subtrahend: number | BigFloat53, difference?: BigFloat53): BigFloat53;
    /** Round towards zero, to (at least) given number of base 2^53 fractional digits. */
    truncate(fractionLimbCount: number): this;
    round(decimalCount: number): this;
    valueOf(): number;
    /** Convert to string in any even base supported by Number.toString.
      * @return String in lower case. */
    toString(base?: number): string;
    /** List of components ordered by increasing exponent. */
    private limbList;
    private len;
}
